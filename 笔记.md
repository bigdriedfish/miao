## Reverse  a  Linked List     (2019-01-10,09-06-51)

```js
var reverseList = function(head) {
    if (!head) {
        return head
    }
    var leftpointer = null
    var middlepointer = null
    var rightpointer = head
    while (rightpointer) {
       leftpointer = middlepointer
       middlepointer = rightpointer
       rightpointer = head.next
       middlepointer.next = leftpointer
           }
    return middlepointer
}
```

```js
var reverseList = function(head) {
    if (!head || !head.next) {
        return head
    }
    var tail = head.next
    head.next = null
    var newHead = reverseList(tail)
    tail.next = head
    return newHead
}
```

## Higher-Order Function (高阶函数)

## 2019-01-11,09-10

1. ```js
   sin(x) = sigma(0, 1000, f)
   function factorial(n) {
       if (n == 0) {
           return 1
       }	else {
           return n * factorial(n - 1)
       }
   }
   function sigma (start, end, f) {
       var result = 0
       for (var x = start; x <= end; x++) {
           result += f(x)
       }
       return result
   }
   function sin(x) {
       function f(n) {
       return Math.pow(-1, n) * Math.pow(x, 2 * n + 1) / factorial (2 * n + 1)
   }
       return sigma(0, 40 , f)
   }
    // 第三次测验中数学公式题
   ```


## 2019-01-14,11-18

- ```js
  [1,2,3,4,5,6,7].reduce((??,currItem) => {
      
  },????)
   -> [1,3,5,7]
  //reduce实现fliter函数
  ----------------------------------------
  [1,2,3,4,5,6,7].reduce((result,currItem) => {
      if (currItem % 2) {
          result.push(currItem)
      }
      return result
  },[])
  ----------------------------------------
  function fliter(ary, test) {
      return ary.reduce((result, currItem, i, ary) => {
      if (currItem % 2) {
          result.push(currItem)
      }
      return result
  },[])
  }
  ```

- ```javascript
  [1,3,5,7].reduce((??,currItem) => {
      
  },????)
   -> [1,9,25,49]
   //用reduce实现map函数
  ---------------------------------------------------------------------
   [1,3,5,7].reduce((result,currItem) => {
     return result.push(currItem * currItem) , result
  },[])
  //可改写如下
  [1,3,5,7].reduce((result,currItem) => (result.push(currItem * currItem) , result),[])
  ---------------------------------------------------------------------
  function map(ary, mapper) {
      return ary.reduce((result, currItem, i, ary) => {
          result.push(mapper(currItem, i, ary))
      }, [])
  }
  ```

- ```js
  [1,3,5,7].reduce((??,currItem) => {
      
  },????)
  //reduce改写forEach函数
  ----------------------------------------------------------------------
  function forEach(ary, action) {
      ary.reduce((x, currItem, i, ary) => {
          action(currItem, i, ary)
      },null)
  }
  ```

- ```js
  function bind(f, omit, ...fixedArgs) {
      return function(...args) {
          return f(...fixedArgs, ...args)
      }
  }
  function f(a, b, c) {
      return a+b+c
  }
  f2 = bind(f, null, 1, 2)
  f2(5) -> 8
  //实现bind函数
  ```

  ```js
  //对数组中的每个元素都执行一个操作
  function forEach(ary, action) {}
  //把数组中的每个元素转换为对应的另一个值
  function map(ary, mapper) {}
  //把数组中满足特定条件的元素留下来
  function filter(ary, test) {}
  ```
  ```js
        function filter(ary, test) {
          return ary.reduce((result, currItem, i, ary) => {
            if (test(currItem, i, ary)) {
              result.push(currItem)
            }
            return result
          }, [])
        }
  ```
 ```js
    function map(ary, mapper) {
      return ary.reduce((result, currItem, i, ary) => {
        result.push(mapper(currItem, i, ary))
        return result
      }, [])
    }
 ```
 ```js
    function forEach(ary, action) {
      ary.reduce((x, currItem,i,ary) => {
        action(currItem, i, ary)
      }, null)
    }
 ```
  

## 2019-01-15, 15-36-44 //高频面试题flatten，flattenDeep

- ```js
    
    function  flatten(ary) {
      var result = []
      
      for (var item of ary) {
        if (Array.isArray(item)) {
          for (var val of item) {
            result.push(val)
          }
          }	else {
            result.push(item)
          }
        return result
    }
     //只做一次flatten操作     
  ```
- ```js
        function flatten(ary) {
          return [].contact(...ary)
        }
        [0].concat(['a','b'],1,2,3)
                //更简便写法
  ```
- ```js
		function flattenDeep(ary) {
          var result = []
          for (var item of ary) {
		    if (Array.isArray(item)) {
            result.push(...flattenDeep(item))
		    }	else {
		    result.push(item)
		    }
		  }
		  return result
		}
  ```
- ```js
 			
			function flattenDeep(ary) {
				return ary.reduce((result,item) => {
          if (Array.isArray(item)) {
            result.push(...flattenDeep(item))
					}	else {
						result.push(item)
					}
					return result
				},[])
            }                   
            //reduce改写
  ```
- ```js	
    var flattenDeep = ary =>ary.reduce((result,item) => (Array.isArray(item)?result.push(...flattenDeep(item)):result.push(item) , result), [])
    //箭头函数 !!!!!!important,接上方改写
  ```
- ```js
    function flattenDeep(ary) {
    return flattenDepth(ary, Infinity)
    }

    function flattenDepth(ary, depth = 1) {
    if (depth == 0) {
        return ary.slice()
    }
    return ary.reduce((result, item) => {
        if (Array.isArray(item)) {
        result.push(...flattenDepth(item, depth - 1))
        } else {
        result.push(item)
        }
        return result
    }, [])
    }
  ```
- ```js
    function flattenDepth(ary, depth = 1) {
      while(depth--) {
      ary = flatten(ary)
      }
      return ary
    }
  ```
- ```js
    function flattenDeep(ary) {
      return flattenDepth(ary, Infinity)
    }

    function flattenDeep(ary) {
      var result = []
      for(var item of ary) {
      if (Array.isArray(item)) {
        result.push(...flattenDeep(item))
      } else {
        result.push(item)
      }
      }
      return result
    }
  ```
- ```js
    function flatten(ary) {
    // return flattenDepth(ary)
    // return [].concat(...ary)
      var result = []

      for(var item of ary) {
        if (Array.isArray(item)) {
        for(var val of item) {
          result.push(val)
        }
        } else {
          result.push(item)
        }
    }

    return result
    }
  ```
- ```js
    function every(ary, test) {
      for(var i = 0; i < ary.length; i++) {
        if (!test(ary[i], i, ary)) {
        return false
        }
      }
      return true
    }

    function some(ary, test) {
      return !every(ary, function(...args) {
      return !test(...args)
      })
    }
     //用every改写some       

    function some(ary, test) {
      for(var i = 0; i < ary.length; i++) {
        if (test(ary[i], i, ary)) {
          return true
        }
      }
      return false
    }

    function every(ary, test) {
    return !some(ary, (...args) => !test(...args))
    }
    //用some改写every
  ```
##2019-01-17,14-37     树与二叉树
- 完全二叉树
- 满二叉树
- 数组元素存储的是节点而非节点的值
- 0号节点存储1,2；1号节点存储3,4；n号节点存储 2*n+1 和 2*n+2；
  
- ```js
    //把根节点在rootPos未知的顺序存储的二叉树
    //转换为一个链式二叉树(二叉链表)
    function ary2tree(ary, rootPos) {
      if (ary.length == 0) {
        return null
      }
      if (rootPos > ary.length - 1) {
        return null
      }
      if (ary[rootPos] === null) {
        return null
      }
      return {
        val: ary[rootPos],
        left: ary2tree(ary, rootPos * 2 + 1)
        right: ary2tree(ary, rootPos * 2 + 2)
      }
    }
  ```
- ```js
    //将二叉树root放入一个数组
    //根节点放在rootPos的位置
    //var ary = []
    function tree2ary(root, ary = [], rootPos = 0) {
      //ary = ary || []
      if (!root) {
        return []
      }
      ary[rootPos] = root.val
      tree2ary(root.left, ary, rootPos * 2 + 1)
      tree2ary(root.right, ary, rootPos * 2 + 2)
    }
  ```
- ```js
    function ary2treeLC() {
      if (ary.length == 0) {
        return null
      }
      var rootNode = {
        val: val,
        left: null,
        right: null
      }
      var queue = [rootNode]
      var leftused = false
      for (var i = 1; i < ary.length; i++) {
        if (val) {
          var node = {
            val: val,
            left: null,
            right: null
          }
          queue.push(node)
        } else {
          node = null
        }
        if (!leftused) {
          queue[0].left = node
          leftused = true
        } else	{
          queue[0].right = node
          leftused = false
          queue.shift()
        }
      }
    }
  ```
- ```js
    function condensedArray2Tree(ary) {
    if (ary.length === 0) {
      return null
    }
    var queue = []
    var root = {
      val: ary[0],
      left: null, right: null
    }

    queue.push(root)

    var node

    for(var i = 1; i < ary.length; i++) {
      node = queue.shift()
      if (ary[i] != null) {
        node.left = {
          val: ary[i],
          left: null, right: null
        }
        queue.push(node.left)
      }

      i++

      if (ary[i] != null) {
        node.right = {
          val: ary[i],
          left: null, right: null
        }
        queue.push(node.right)
      }

    }

    return root
  }
  ```
- ```js
    function tree2aryLC(root) {
    if (!root) {
      return []
    }
    var result = []
    var queue = [root]

    while(queue.length) {
      var node = queue.shift()
      if (node) {
        result.push(node.val)
        queue.push(node.left, node.right)
      } else {
        result.push(null)
      }
    }

    return result
  }
  ```
- ```js
    function tree2condensedArray(root) {
    if (!root) {
      return []
    }
    var result = [root.val]

    var queue = [root]
    var node

    while (node = queue.shift()) {
      if (node.left) {
        result.push(node.left.val)
        queue.push(node.left)
      } else {
        result.push(null)
      }

      if (node.right) {
        result.push(node.right.val)
        queue.push(node.right)
      } else {
        result.push(null)
      }
    }

    return result
  }
  ```

###二叉树遍历
####先序遍历 //  root 左 右
```js
    function preOrderTraverse(root,action) {
      if (root) {
        console.log(root.val)
        preOrderTraverse(root.left, action)
        preOrderTraverse(root.right, action)
      }
    }
```
####中序遍历  // 左 root  右
```js
    function inOrderTraverse(root, action) {
      if (root) {
      inOrderTraverse(root.left, action)
      action(root.val)
      inOrderTraverse(root.right, action)
    }
    }
```
####后序遍历  //  左  右  root
```js
    function postOrderTraverse(root, action = console.log) {
      if (root) {
      postOrderTraverse(root.left, action)
      postOrderTraverse(root.right, action)
      action(root.val)
    }
    }
```


  		
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			


## Reverse  a  Linked List     (2019-01-10,09-06-51)

```js
var reverseList = function(head) {
    if (!head) {
        return head
    }
    var leftpointer = null
    var middlepointer = null
    var rightpointer = head
    while (rightpointer) {
       leftpointer = middlepointer
       middlepointer = rightpointer
       rightpointer = head.next
       middlepointer.next = leftpointer
           }
    return middlepointer
}
```

```js
var reverseList = function(head) {
    if (!head || !head.next) {
        return head
    }
    var tail = head.next
    head.next = null
    var newHead = reverseList(tail)
    tail.next = head
    return newHead
}
```

## Higher-Order Function (高阶函数)

## 2019-01-11,09-10

1. ```js
   sin(x) = sigma(0, 1000, f)
   function factorial(n) {
       if (n == 0) {
           return 1
       }	else {
           return n * factorial(n - 1)
       }
   }
   function sigma (start, end, f) {
       var result = 0
       for (var x = start; x <= end; x++) {
           result += f(x)
       }
       return result
   }
   function sin(x) {
       function f(n) {
       return Math.pow(-1, n) * Math.pow(x, 2 * n + 1) / factorial (2 * n + 1)
   }
       return sigma(0, 40 , f)
   }
    // 第三次测验中数学公式题
   ```


## 2019-01-14,11-18

- ```js
  [1,2,3,4,5,6,7].reduce((??,currItem) => {
      
  },????)
   -> [1,3,5,7]
  //reduce实现fliter函数
  ----------------------------------------
  [1,2,3,4,5,6,7].reduce((result,currItem) => {
      if (currItem % 2) {
          result.push(currItem)
      }
      return result
  },[])
  ----------------------------------------
  function fliter(ary, test) {
      return ary.reduce((result, currItem, i, ary) => {
      if (currItem % 2) {
          result.push(currItem)
      }
      return result
  },[])
  }
  ```

- ```javascript
  [1,3,5,7].reduce((??,currItem) => {
      
  },????)
   -> [1,9,25,49]
   //用reduce实现map函数
  ---------------------------------------------------------------------
   [1,3,5,7].reduce((result,currItem) => {
     return result.push(currItem * currItem) , result
  },[])
  //可改写如下
  [1,3,5,7].reduce((result,currItem) => (result.push(currItem * currItem) , result),[])
  ---------------------------------------------------------------------
  function map(ary, mapper) {
      return ary.reduce((result, currItem, i, ary) => {
          result.push(mapper(currItem, i, ary))
      }, [])
  }
  ```

- ```js
  [1,3,5,7].reduce((??,currItem) => {
      
  },????)
  //reduce改写forEach函数
  ----------------------------------------------------------------------
  function forEach(ary, action) {
      ary.reduce((x, currItem, i, ary) => {
          action(currItem, i, ary)
      },null)
  }
  ```

- ```js
  function bind(f, omit, ...fixedArgs) {
      return function(...args) {
          return f(...fixedArgs, ...args)
      }
  }
  function f(a, b, c) {
      return a+b+c
  }
  f2 = bind(f, null, 1, 2)
  f2(5) -> 8
  //实现bind函数
  ```

  ```js
  //对数组中的每个元素都执行一个操作
  function forEach(ary, action) {}
  //把数组中的每个元素转换为对应的另一个值
  function map(ary, mapper) {}
  //把数组中满足特定条件的元素留下来
  function filter(ary, test) {}
  ```
  ```js
        function filter(ary, test) {
          return ary.reduce((result, currItem, i, ary) => {
            if (test(currItem, i, ary)) {
              result.push(currItem)
            }
            return result
          }, [])
        }
  ```
 ```js
    function map(ary, mapper) {
      return ary.reduce((result, currItem, i, ary) => {
        result.push(mapper(currItem, i, ary))
        return result
      }, [])
    }
 ```
 ```js
    function forEach(ary, action) {
      ary.reduce((x, currItem,i,ary) => {
        action(currItem, i, ary)
      }, null)
    }
 ```
 ## 2019-01-15, 15-36-44 //高频面试题flatten，flattenDeep
- ```js
    
    function  flatten(ary) {
      var result = []
      
      for (var item of ary) {
        if (Array.isArray(item)) {
          for (var val of item) {
            result.push(val)
          }
          }	else {
            result.push(item)
          }
        return result
    }
     //只做一次flatten操作     
  ```
- ```js
        function flatten(ary) {
          return [].contact(...ary)
        }
        [0].concat(['a','b'],1,2,3)
                //更简便写法
  ```
- ```js
		function flattenDeep(ary) {
          var result = []
          for (var item of ary) {
		    if (Array.isArray(item)) {
            result.push(...flattenDeep(item))
		    }	else {
		    result.push(item)
		    }
		  }
		  return result
		}
  ```
- ```js
 			
			function flattenDeep(ary) {
				return ary.reduce((result,item) => {
          if (Array.isArray(item)) {
            result.push(...flattenDeep(item))
					}	else {
						result.push(item)
					}
					return result
				},[])
            }                   
            //reduce改写
  ```
- ```js	
    var flattenDeep = ary =>ary.reduce((result,item) => (Array.isArray(item)?result.push(...flattenDeep(item)):result.push(item) , result), [])
    //箭头函数 !!!!!!important,接上方改写
  ```
- ```js
    function flattenDeep(ary) {
    return flattenDepth(ary, Infinity)
    }

    function flattenDepth(ary, depth = 1) {
    if (depth == 0) {
        return ary.slice()
    }
    return ary.reduce((result, item) => {
        if (Array.isArray(item)) {
        result.push(...flattenDepth(item, depth - 1))
        } else {
        result.push(item)
        }
        return result
    }, [])
    }
  ```
- ```js
    function flattenDepth(ary, depth = 1) {
      while(depth--) {
      ary = flatten(ary)
      }
      return ary
    }
  ```
- ```js
    function flattenDeep(ary) {
      return flattenDepth(ary, Infinity)
    }

    function flattenDeep(ary) {
      var result = []
      for(var item of ary) {
      if (Array.isArray(item)) {
        result.push(...flattenDeep(item))
      } else {
        result.push(item)
      }
      }
      return result
    }
  ```
- ```js
    function flatten(ary) {
    // return flattenDepth(ary)
    // return [].concat(...ary)
      var result = []

      for(var item of ary) {
        if (Array.isArray(item)) {
        for(var val of item) {
          result.push(val)
        }
        } else {
          result.push(item)
        }
    }

    return result
    }
  ```
- ```js
    function every(ary, test) {
      for(var i = 0; i < ary.length; i++) {
        if (!test(ary[i], i, ary)) {
        return false
        }
      }
      return true
    }

    function some(ary, test) {
      return !every(ary, function(...args) {
      return !test(...args)
      })
    }
     //用every改写some       

    function some(ary, test) {
      for(var i = 0; i < ary.length; i++) {
        if (test(ary[i], i, ary)) {
          return true
        }
      }
      return false
    }

    function every(ary, test) {
    return !some(ary, (...args) => !test(...args))
    }
    //用some改写every
  ```
##2019-01-17,14-37     树与二叉树
- 完全二叉树
- 满二叉树
- 数组元素存储的是节点而非节点的值
- 0号节点存储1,2；1号节点存储3,4；n号节点存储 2*n+1 和 2*n+2；  
- ```js
    //把根节点在rootPos未知的顺序存储的二叉树
    //转换为一个链式二叉树(二叉链表)
    function ary2tree(ary, rootPos) {
      if (ary.length == 0) {
        return null
      }
      if (rootPos > ary.length - 1) {
        return null
      }
      if (ary[rootPos] === null) {
        return null
      }
      return {
        val: ary[rootPos],
        left: ary2tree(ary, rootPos * 2 + 1)
        right: ary2tree(ary, rootPos * 2 + 2)
      }
    }
  ```
- ```js
    //将二叉树root放入一个数组
    //根节点放在rootPos的位置
    //var ary = []
    function tree2ary(root, ary = [], rootPos = 0) {
      //ary = ary || []
      if (!root) {
        return []
      }
      ary[rootPos] = root.val
      tree2ary(root.left, ary, rootPos * 2 + 1)
      tree2ary(root.right, ary, rootPos * 2 + 2)
    }
  ```
- ```js
    function ary2treeLC() {
      if (ary.length == 0) {
        return null
      }
      var rootNode = {
        val: val,
        left: null,
        right: null
      }
      var queue = [rootNode]
      var leftused = false
      for (var i = 1; i < ary.length; i++) {
        if (val) {
          var node = {
            val: val,
            left: null,
            right: null
          }
          queue.push(node)
        } else {
          node = null
        }
        if (!leftused) {
          queue[0].left = node
          leftused = true
        } else	{
          queue[0].right = node
          leftused = false
          queue.shift()
        }
      }
    }
  ```
- ```js
    function condensedArray2Tree(ary) {
    if (ary.length === 0) {
      return null
    }
    var queue = []
    var root = {
      val: ary[0],
      left: null, right: null
    }

    queue.push(root)

    var node

    for(var i = 1; i < ary.length; i++) {
      node = queue.shift()
      if (ary[i] != null) {
        node.left = {
          val: ary[i],
          left: null, right: null
        }
        queue.push(node.left)
      }

      i++

      if (ary[i] != null) {
        node.right = {
          val: ary[i],
          left: null, right: null
        }
        queue.push(node.right)
      }

    }

    return root
  }
  ```
- ```js
    function tree2aryLC(root) {
    if (!root) {
      return []
    }
    var result = []
    var queue = [root]

    while(queue.length) {
      var node = queue.shift()
      if (node) {
        result.push(node.val)
        queue.push(node.left, node.right)
      } else {
        result.push(null)
      }
    }

    return result
  }
  ```
- ```js
    function tree2condensedArray(root) {
    if (!root) {
      return []
    }
    var result = [root.val]

    var queue = [root]
    var node

    while (node = queue.shift()) {
      if (node.left) {
        result.push(node.left.val)
        queue.push(node.left)
      } else {
        result.push(null)
      }

      if (node.right) {
        result.push(node.right.val)
        queue.push(node.right)
      } else {
        result.push(null)
      }
    }

    return result
  }
  ```

 ###二叉树遍历
   ####先序遍历 //  root 左 右
```js
    function preOrderTraverse(root,action) {
      if (root) {
        console.log(root.val)
        preOrderTraverse(root.left, action)
        preOrderTraverse(root.right, action)
      }
    }
```
####中序遍历  // 左 root  右
```js
    function inOrderTraverse(root, action) {
      if (root) {
      inOrderTraverse(root.left, action)
      action(root.val)
      inOrderTraverse(root.right, action)
    }
    }
```
####后序遍历  //  左  右  root
```js
    function postOrderTraverse(root, action = console.log) {
      if (root) {
      postOrderTraverse(root.left, action)
      postOrderTraverse(root.right, action)
      action(root.val)
    }
    }
```
############leetcode 第13题，Roman to integer  map写不会
##2019-01-18,09-12-44
- 指针只能拿到其节点后面的值，拿不到前面的
- 二叉搜索树(排序二叉树)：根节点总是比左子树任何一个节点都要大，比右边的小，子节点也满足


- ```js
      //将val插入BST中
      //并返回bst的根节点
      function insertIntoBST(bst, val) {
        if (!bst) {
          val: val,
          left: null,
          right: null,
        } else {
          if (val < bst.val) {
            bst.left = insertIntoBST(bst.left, val)
          } else {
            bst.right = insertIntoBST(bst.right, val)
          }
          return bst
        }
      }


      function bsrSort(ary) {
        var bst = null
        for (var val of ary) {
          bst = insertIntoBST(bst, val)
        }
        var result = []
        inOrderTraverse(bst, function(val){
          result.push(val)
        })
        return result
      }
  ```
- 平衡二叉树： 		
 		
- 快排：
 ``` js
  function quickSort(ary) {
    if (ary.length < 2) {
      return ary
      return ary.slice()
    }

    var pivotIndex = Math.random() * ary.length >> 0
    var pivot = ary[pivotIndex]

    var left = []
    var middle = []
    var right = []

    for(var item of ary) {
      if (item < pivot) {
        left.push(item)
      } else if (item > pivot) {
        right.push(item)
      } else {
        middle.push(item)
      }
    }

    return [...quickSort(left), ...middle, ...quickSort(right)]
  }     //不推荐

  function quickSort2(ary, left = 0, right = ary.length - 1) {
    if (right - left <= 0) {
      return ary
    }
    var pivotIndex = Math.floor(Math.random() * (right - left + 1) + left)
    var pivot = ary[pivotIndex]

    swap(ary, right, pivotIndex)

    for(var i = left - 1, j = left; j < right; j++) {
      if (ary[j] < pivot) {
        i++
        swap(ary, i, j)
      }
    }
    i++
    swap(ary, right, i)
    quickSort2(ary, left, i - 1)
    quickSort2(ary, i + 1, right)
    return ary
  } 		//推荐	
 ```					
##2019-01-23， 16.00
### Set类的实现及作业
 ```js
var MySet = (function(){
  function MySet(init = []) {
    if (new.target !== MySet) {
      return new MySet(init) 
    }
    if (!(this instanceof MySet)) {
      return new MySet(init)
    }
    this.values = []
    for(var val of init) {
      this.add(val)
    }
  }
  function findIndex(val) {
    if (val != val) {
      for (var i = 0; i < this.values.length; i++) {
        if (this.values[i] != this.values[i]) {
          return i
        }
      }
      return -1
    } else {
      return this.values.indexOf(val)
    }
  }
  MySet.prototype = {
    add: function(val) {
      if (!this.has(val)) {
        this.values.push(val)
      }
      return this
    },
    delete: function(val) {
      var pos = findIndex.call(this, val)
      if (pos >= 0) {
        this.values.splice(pos, 1)
      }
      return this
    },
    has: function(val) {
      return findIndex.call(this, val) >= 0
    },
    clear: function(){
      this.values.length = 0
      return this
    },
    forEach: function(iterator){
      this.values.forEach((val) => {
        iterator(val, val, this)
      })
      return this
    },
    get size() {
      return this.values.length
    }
  }
  return MySet
}())

 ```
##2019-01-25 			
 ```js
  //slice的另一种实现
  //数组去重也是一个面试常问问题
   Array.prototype.slice2 = function(start = 0, end = this.length){
     var result = []
     for (var i = start; i < end; i++) {
       result.push(this[i])
     }
     return result
  }  
  [1,2,3].slice.call(arguments) //语义：将arguments这个类数组对象转换成真的数组
  [].slice.call({0:1,2:3,2:5,length:3})//创建一个[1,3,5]数组，  为什么他能转换成数组
  [].map.call({0:1,2:3,2:5,length:3},it => it)
  Array.from({0:1,1:2,length:2})
  //去重，面试常见问题
 ```			
###lodash函数讲解
  ```js
    function after(n, func) {
      var calledTimes = 0
      return function(...args) {
        calledTimes++
        if (calledTimes >= n) {
          return func(...args)
        }
      }
    }
  ```
  ```js
    function unary(func) {
      return function (...args) {
        var first = args.slice(0,1)
        return func.call(this, ...first)
      }
    }
  ```
  ```js
    function ary(func, n = func.length) {
      return function(...args) {
        var initials = args.slice(0, n) {
          return func(...initials)
        }
      }
    }
  ```
  ```js
  function flip(func) {
    return function (...args) {
      return func(...args.reverse())
    }
  }


  unary = flip(ary).bind(null, 1)
  parseInt("1101", 2)
  ```
  ```js
    ["1","2","3","4"].map(parseInt) //parseInt函数标准接收两个参数，map接收3个参数，map给parseInt传了字符串，下标，数组本身
    parseInt('1', 0 ,[])
    parseInt('2', 1 ,[])
    parseInt('3', 2 ,[])
    ["1","2","3","4"].map(unary(parseInt))
    ["1","2","3","4"].map(function parseInt(a) {return parseInt(a)})         //两种方法即可解决
  ```
  ```js
    function negate(predicate) {
      return function(...args) {
        return !predicate(...args)
      }
    }    // 否定的是逻辑
    [1,2,3,4,5,6,7,8,9].filter(isPrime) -> [2,3,5,7]
    isNotPrime = negate(isPime)
    [1,2,3,4,5,6,7,8,9].filter(negate(isPime)) -> [1,4,6,8,9]
    //改写some every
    function some(ary, test) {
      return !every(ary, negate(test))
    }
  ```
  ```js
    function spread(func) {
      return function (array) {
        return func.apply(this, array)
      }
    }
    //将数组展平传过去
    //eg:
    [
      ['2', 5],
      ['33',4],
      ['AFD3',16],
      ['1111',2],
    ].map(spread(parseInt))

    ._curry函数自己写
  ```
  ```js
    _.uniqBy([{'x': 1}, {'x': 2}, {'x': 3}], it => it.x)
    _.uniqBy([{'x': 1}, {'x': 2}, {'x': 3}], _.property('x'))
    function property(name) {
      return function(obj) {
        return obj[name]
      }
    }

  ```
  ```js
    function matches (target) {
      return function (obj) {
        if (obj[prop] != target[prop]) {
          if (obj[prop] != target[prop]) {
            return false
          }
        }
        return true
      }
    }
  ```
##2019-01-27
* 严格模式面试时前面看一下
* 静态类型
* eval直接使用名字时在当前作用域生效，否则在全局作用域生效    * 如果你间接的使用 eval()，比如通过一个引用来调用它，而不是直接的调用 eval 。 从 ECMAScript 5 起，它工作在全局作用域下，而不是局部作用域中。
* (0, eval)   
* (0,eval)这个表达式中eval因为逗号运算符的干预被隐性的计算成了一个右值而不再是一个引用，从而使其成为了规范中明确定义的一种Indirect call的形态。 
* 逗号表达式的值永远为最后一项。
* eval讲解链接：
  - https://www.oschina.net/translate/global-eval-what-are-the-options
  - http://ju.outofmemory.cn/entry/150898
  ```js
    var foo = 'golbal foo'
    var obj = {
      foo: 'obj.foo'
      method: function () {
        return this.foo
      }
    };
    console.log(obj.method());   //obj.foo
    console.log((1, obj.method)());  //global.foo
  ```


* 测试框架，mocha
  
  ```js
  
  ```
  ```js
  
  ```
  ```js
  
  ```
  ```js
  
  ```
##2019-01-29  堆  优先队列
  01. 堆：是一棵完全二叉树，节点数为n时，层数一定为log2N
      - 任意父节点都比其两个子节点大或相等，大顶堆
      - 任意父节点都比其两个子节点小或相等，小顶堆
  02. 删除时将堆尾元素移到最前面，插入时从最后一个左子树开始










##2019-02-16 正则表达式 RegExp
#### 零宽断言(他匹配一个满足特定条件的位置)
  01. (?=expr) 正预测 断言摸个位置的右边满足expr (positive lookahead)
  02. (?!expr) 负预测 断言某个位置的右边不满足expr (negative lookahead)
  03. (?<=expr) 正回顾 断言某个位置的左边满足expr  (lookbehead)
  04. (?<!expr) 负回顾 断言某个位置的左边 不满足expr
  可以在js里使用(?=expr)(....)(desired) 来模拟回顾零宽断言 
  - 网站推荐：https://regexper.com/ https://regex101.com/

  - (?<=\W)(?=\w)|(?<=\w)(?=\W)|(?<![^])(?=\w)|(?<=\w)(?![^])相当于\b
  - (?![^])相当于$
  - (?<![^])相当于^

##2019-02-17 正则
  - String.raw``:
    - 原理：
      - ```js
              f`${2**3}he${2*3}llo${2 +3} wo\\rld`
              ['he', 'llo', 'wo\rld', raw: ['he', 'llo','wo\\rld'] ]

              8
              6
              5
              f`he${2**3}llo${2*3} wo\\rld${2 +3}`
              ['he', 'llo', ' wo\rld', raw:['he', 'llo', ' wo\\rld']]
              8
              6
              5

        ```
    - String.raw``函数实现
     - ```js
            function raw(parts, ...interpolations) {
              var result = parts.raw[0]
              for(var i = 1; i < parts.raw.length; i++) {
                result += interpolations[i - 1] + parts.raw[i]
              }
              return result
            }

       ```
##2019-02-18 回溯
  - Tagged String
    - f`aa\\b${a}cc${d}`
      f会运行，接受的第一个参数是一个数组
      数组的每一项是被插值符分隔出来的若干个字符串
      同时这个数组上还有一个raw属性，也是一个数组，里面是所有片段里的内容未被转义之前的内容
      f还会接收若干个剩余的参数，其值与插值符号内的表达式的值一一对应
  - (?:xxxx)表示非捕获分组
  - /(expr)\1/ 其中\1表示前面(expr)捕获到的具体内容，以此类推；反/后向引用



  1. match, 不考虑正则表达式的lastIndex属性
    - 当正则表达式有g标志的时候，匹配出所有能满足整条正则表达式的内容
    - 当没有g标志的时候，匹配出第一条能满足的内容，同时把分组捕获到的内容也放入结果数组
  2. replace(RegExp|String,Steing|Function)
    - 两个参数都是字符串:匹配第一次出现的内容为目标内容
    - 首参为正则
      - 次参为字符串，里免得$&,$2是特殊内容，表示匹配到的内容以及各个分组捕获到的内容
      - 次参为函数，把整个匹配到的内容以及个分组捕获到的内容传给函数作为参数，把函数返回值插入被替换位置，有多少次匹配，函数就会调用多少次
  3. re.exec(str)方法
    - 如果re不带g标志，则完全等同于str.match(re)
    - 如果re带有g标志，则从str的re.lastIndex位置开始查找，查找成功之后把re.lastIndex置为匹配位置的后一个位置，查找不成功的时候，返回null，把lastIndex置为0
  4. str,split(String|RegExp)
    - 当参数是字符串时，按字符串把原字符串拆成数组
    - 当参数为正则时，安正则把字符串拆成各部分的数组，但是当正则里有捕获分组时，分组捕获到的内容也会出现在结果数组的相应位置
  
##2019-02-20 在dom中查找元素及相关函数的实现
  - ```js
      function getElementsByTagName(node, tagName) {
        var result = []
        tagName = tagName.toUpperCase()
        traverse(node, n => {
          if (n.tagName == tagName) {
            result.push(n)
          }
        })
        return result
      }
      //不带根节点的多叉树遍历
      function traverse(node, action) {
        if (node.nodeType == document.ELEMENT_NODE) {
          for (var i = 0; i < node.children.length; i++) {
            action(node.children[i])
            traverse(node.children[i])
          }
        }
      }
    ```
  - ```js 
      //未写完 自己补充
      function getElementById(id) {
        var result = null
        traverse(document.documentElement, node => {
          if (node.id == id) {
            result = node
            return false
          }
        })
        return result
      }

      //带根节点的多叉树遍历
      function traverse(node, action) {
        if (node.nodeType == document.ELEMENT_NODE) {
          action(node)
          for (var i = 0; i < node.children.length; i++) {
            traverse(node.children[i],action)
          }
        }
      }
      //二叉树遍历
      function traverse(root, action) {
        var r
        if (root) {
          r = action(root.left)
          if (r === false) return 
          traverse(root.left, action)
          r = action(root.right)
          if (r === false) return 
          traverse(root.right, action)
        }
      }


      //直接写
      function getElementById(id,node = document.documentElement) {
        if (node.id == id) {
          return node
        } else {
          for (var i = 0; i < node.children.length; i++) {
            var ret = getElementById(id, node.children[i])
            if (ret) {
              return ret
            }
          }
          return null
        }
      }
    ```

##2019-02-21 修改DOM树及需要注意的问题
  - ```js  
      //克隆
      function cloneNode(node) {
        if (node.nodeType == document.ELEMENT_NODE) {
          var result = document.createElement(node.tagName)
          for (var i = 0; i < node.childNodes.length; i++) {
            result.appendChild(cloneNode(node.childNodes[i]))
          }
          return result
        } else if (node.nodeType == document.TEXT_NODE) {
          return document.createTextNode(node.nodeValue)
        } else if (node.nodetype ==  document.COMMENT_NODE) {
          return document.createComment(node.data)
        }
      }
    ```
  - node.style.backgroundColor = "red" 修改样式，为内联样式
  - node.classList.add/remove/toggle/contains  操作类
  - node.dataset.foo = 'foo'   操作标签的 data- 属性 驼峰式  get data-set attribute and so on   
  - innerHTML 获取到dom节点内部的HTML代码
  - outerHTML 获取到dom节点全部的HTML代码
  - ```js 
        function getOuterHTML(node) {
          if (node.nodeType == document.ELEMENT_NODE) {
            var tag = node.nodeName.toLowerCase()
            var ret = `<${tag}>
            ${Array.from(node.childNodes).map(getOuterHTML).join('')}
            <${tag}>`
          } else if(node.nodeType == document.TEXT_NODE) {
            return node.nodeValue
          }
        }         //没有考虑到注释节点
      ```
  - innerText 去掉标签，只留文本
  - outerText 
  - textContent   innerText会受css影响，textContent不会
  - ```js
      function elt(nodeName, ...children) {
        var node = document.createElement(nodeName)
        for (var child of children) {
          node.appendChild(child)
        }
        return node
      }//即 elt('p', elt('a', 'soo'),elt('span', 'bar')输出<p><a>soo</a><span>bar</span></p>
      //设置属性
      function elt(nodeName, attrs, ...children) {
        var node = document.createElement(nodeName)
        attrs = attrs || {}
        for (var key in attrs) {
          var val = attrs[key]
          node.setAttribute(key, val)
        }
        for (var child of children) {
          node.appendChild(child)
        }
        return node
      } // elt('p', {id: '99'}, elt('a', {href: 'baidu.com'}, 'soo'), elt('span', null, 'bar')
        //<p id = "99"><a href: "baidu.com">soo</a><span>bar</span></p>
    ```
  - ```js
      function dom(ary) {
        var htmlCode = ary.join('')
        var div = document.createElement('div') 
        div.innerHTML = htmlCode
        return div.firstChild
      }
      //dom`
        <p>
          <a>foo</a>
          <span>bar</span>
        </p> 性能损耗更大  
    ```  
  - 

##2019-02-23
###事件对象
- ```js
    var btn = document.querySelector("button")
    btn.addEventListener('mousedown',function(e//event) {
      console.log(e.which//event.which)
    })//早版本的IE浏览器不会以参数的形式传递而是在事件发生的过程中将事件存储在一个名为event的全局变量中（现在也依旧可用）
  ```
##2.23资料缺失，原因移动md文件是忘记保存，永远记住


- 在捕获阶段，先会触发在最远的祖先元素上绑定的捕获阶段的函数，然后依次触发
- 在目标元素上运行时，不考虑是捕获或者是冒泡，按照绑定的顺序运行
- 冒泡阶段，与捕获阶段相反
- ```js
  <body>

    <a href="https://www.baidu.com" target="_blank">aaa</a>
    <div>
      <p>
        ppppp
        <button>aa</button>
        ppppp
      </p>
    </div>
  <script>
    document.querySelector('a').addEventListener('click', e => {
      e.preventDefault()
    })
    var div = document.querySelector('div')
    var p = document.querySelector('p')
    var btn = document.querySelector('button')
    div.addEventListener('click', function(){
      console.log(1)
    }, true)//有true表示捕获
    div.addEventListener('click', function(){
      console.log(2)
    })//表示冒泡
    p.addEventListener('click', function(e){
      console.log(3)
      e.stopPropagation()
    }, true)
    p.addEventListener('click', function(e){
      console.log(3.5)
    }, true)
    p.addEventListener('click', function(){
      console.log(4)
    })
    btn.addEventListener('click', function(){
      console.log(5)
    }, true)
    btn.addEventListener('click', function(){
      console.log(6)
    })
    btn.addEventListener('click', function(){
      console.log(7)
    }, true)
  </script>
  </body>
  ```
- ![捕获目标冒泡](捕获目标冒泡.png)  
- 到target元素就结束了，不会触发到target元素的子元素
- ![捕获target冒泡](捕获target冒泡.png)


- window.addEventListener('beforeunload',xxx,{
  passive:true//明确告诉浏览器该事件处理函数不会调用e.preventDefault(),让浏览器在可能的情况下让默认行为更早发生(如与该事件处理函数同步发生)一般用来优化滚动性能 eg：手指滑动屏幕，屏幕随着手指的滑动来动
  });//文档passive event



##2019-02-25 键盘事件
###鼠标移动，P189例
- which 表示哪一个鼠标按钮被按下：
  * **0** 表示 **无**
  * **1** 表示 **左键**
  * **2** 表示 **中键**
  * **3** 表示 **右键**
  * 无法表示组合鼠标键，此属性总是只展示最先按下去的键
- buttons 表示那些鼠标按钮被按下
  * 它的 **二进制最低位** 表示 **左键**
  * **第二位** 表示 **右键** 
  * **第三位** 表示 **中键**
  * 所以同时按下**中键和右键**将会得到**6** ， 以此类推

- ```js
    const MOUSE_LEFT = 1
    const MOUSE_RIGHT = 2
    const MOUSE_MIDDLE = 4
    if (event.buttons === (MOUSE_LEFT | MOUSE_MIDDLE)) {
    }//按位或 
    open('a.txt', FILE_READ | FILE_WRITE | FILE_APPEND)
  ```
#### mouseover/mouseout 和 mouse enter/mouse leave 
- ```js
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
     div {
        border: 5px solid;
      }
      p {
        margin: 30px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div>
      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Veniam architecto ea illum consequatur sunt rem unde odio debitis veritatis, porro dolores ipsam repudiandae, officia praesentium vitae cupiditate, perferendis possimus! Beatae!</p>
    </div>
  <script>
    var div = document.querySelector('div')
    var p = document.querySelector('p')

    div.addEventListener('mouseover', e => {
      console.log('div over')
      div.style.background = 'violet'
    })
    div.addEventListener('mouseout', e => {
      console.log('div out')
      div.style.background = ''
    })
    p.addEventListener('mouseover', e => {
      console.log('p over')
    })
    p.addEventListener('mouseout', e => {
      console.log('p out')
    })
  </script>
  </body>
  </html> 
  ```
* 因为进入div时，触发mouseover，在进入p标签时，触发了div的mouseout，同时也触发了p标签的mouseover，同时，p标签又冒泡上去，触发div的mouseover，会使div一直显示粉色
- ```js
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
     div {
        border: 5px solid;
      }
      p {
        margin: 30px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div>
      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Veniam architecto ea illum consequatur sunt rem unde odio debitis veritatis, porro dolores ipsam repudiandae, officia praesentium vitae cupiditate, perferendis possimus! Beatae!</p>
    </div>
  <script>
    var div = document.querySelector('div')
    var p = document.querySelector('p')

    div.addEventListener('mouseenter', e => {
      console.log('div enter')
      div.style.background = 'violet'
    })
    div.addEventListener('mouseleave', e => {
      console.log('div leave')
      div.style.background = ''
    })
    p.addEventListener('mouseenter', e => {
      console.log('p enter')
    })
    p.addEventListener('mouseleave', e => {
      console.log('p leave')
    })
  </script>
  </body>
  </html> 
  ```
* 可以使用mouse enter/leave 来替代(非替代，并存)mouse over/out，同时enter与leave事件不冒泡，避免了很多坑，同时jQuery提供了hover方法来处理鼠标进入或移出元素的场景，也可以避开这一问题

##2019-02-26
###加载事件
- 特例：
    - async和defer属性(从外部加载js文件才可)
      此二属性都是允许让js延迟执行，但所有使用了defer属性的script标签一定会按顺序执行，而async无此要求，所有使用了async属性的script可乱序执行

    - script里的js是先于其onload事件执行的
    - 图片及脚本都有另一个事件：onerror
    - window.onload是在页面中所有的资源加载完成的时候触发的，包括图片，脚本，css等
    - window上也有一个onerror事件，页面里出现错误(运行js出错)的时候触发的。严格来说，window.onerror不是一个事件，因为它接收的不是一个事件对象。此功能可以用来实现错误上报
- 补充：
    - domready事件：
      - $(function() {})   DOMContentLoaded事件
      - readystatechange/document.readyState(compelete标志解析完成，老浏览器可用，相当于onload事件，interactive状态相当于DOMContentLoaded事件)
    - HTML5中引入的新事件：
      - 多媒体标签的事件：audio/video
        playing peogress loadstart pause volumechangeended waiting
    - 移动端事件：
      - onorientationchange
        设备方向旋转时触发
      - touch事件
    - window online/offline
    - window.onerror(严格来说不算事件)
    - window.onmessage用于postMessage跨页面通信
    - 拖拽事件：
      - ondrag/drop
      - ondrag end/start/enter/leave/over

##2019-02-26 
### 代码执行时间线及多线程介绍
- 进程与线程的区别：
  - 不同进程之间不能共享内存
  - 同一个进程的多个线程是可以共享这个进程的内存的
  - CPU的时间片轮转是以线为基本单位的

###debounce //必考题 防抖
- ```js
    function debounce(f,duration) {
      var id 
      return function(...args) {
        clearTimeout(id)
        id = setTimeout(f.bind(this, ...args), duration)
      }
    }
  ```
###throttle //必考题 截流
- ```js
    function throttle(f, duration) {
      var lastRunTime = 0
      return function(...args) {
        var now = Date.now()
        if (now - lastRunTime > duration) {
          lastRunTime = now
          return f.call(this, ...args)
        } 
      }
    }
  ```
### 路径化简
- 使用栈，碰到..出栈，或者使用正则
- push-state.html 很重要

##生成器函数yield
- 由生成器函数调用得到的迭代器是可以被for of 直接调用的，forof出来的每一个值不再是那个生成出来的对象，而是对象的value属性
- yeild 语句本身是有返回结果的,从恢复的位置让yield返回 一个结果
  - ```js
      function * f() {
        var a = yield 3
        var b = yield a * a 
        yield b * b
      }
      g = f()
      -> g.next()
      <- {value:3,done:false}
      -> g.next(5)
      <- {value: 25, done: false}
      -> g.next(3)
      <- {value: 9, done: false}
      -> g.next(3)
      <- {value: undefined, done: true}  
    ```
  - g.return(55) //在停住的时候直接暂停
  - g.throw(55)    //在yield语句处抛出错误
  - yield * h()    //yield调用生成器函数，在h()跑完之后再运行后面的代码，    会产生生成器函数中的调用栈    
- ```js
  //手动实现for of 函数
  function FOROF (iter, func) {
    if (iter.toString() !== '[object Generator]') {
       iter = iter[Symbol.iterator]()
    }
	  var generated
	  while (true) {
		  generated = iter.next()
		  if (generated.done) {
			  break
		    }
		if func(generated.value) === false {
			break
		  }
	  }
  }
  ```
- [...log]也可以实现读取，和 for of 类似 
- ```js
  //生成器实现斐波那契数列
  function  * fibb(n) {
	  var a = 0
	  var b = 1
  	for (var i = 0; i < n; i++) {
		  b = b + a 
	  	a = b - a  
		  yield a 
	  }
  }
  for (let val of fibb(5)) {
  	sum += val
  }
  ```
##生成器
  - ```js
    obj = {
      a: 1,
      f: function(){
        return this.a
      }
    }
    var a = 2

    obj.f()      //1
    (obj.f)()    //1 和obj.f()语法树一摸一样 
    (0 || obj.f)()  //2
    //记住
    ```
###生成器函数
  - ```js
    function * f() {
      yield 1//
      yield 2
      yield 3
    }

    iterator = f()
    iterator.next()   --->{
      value:
      done: true/false
    }

    function * f() {
      yield 1
      yield 2 
      yield 3
      yield 4 ,yield 5
    }
    var iterator = f()
    var sum = 0
    var generated
    for (;;) {
      generated = iterator.next()
      if (!generated.done){
        sum += generated.value 
      } else {
        break
      }
    }   
    ```
##symbol
- 没有办法读到的属性
- 原始类型
- js中的原始类型：number boolean string symbol function object
- ```js
  // Symbol.for
  ->c = Symbol.for('foo')
  <-Symbol(foo)
  ->c === Symbol.for('foo')
  <-true
  ```
- Symbol.iterator
##计算机网络
- 每一层必须依赖上一层
- 物理层
  - 总线型缺点：同时只有一个人能发
  - 交换机：每条线可以同时收发，效率会变高，二层设备
  - 集线器：形成广播域，看起来就很笨
  - 指数退避
  - ARP协议：是局域网里的，转成mac地址，不是局域网里的，就不会转换 arp -a查看mac地址
  - ARP抓包： 链路层的
  - 链路层 局域网中的电脑通讯是通过mac地址进行通讯的，需要IP地址也是会转换成mac地址
  - **子网掩码：被写成二进制过后，左边全是1，右边全是0，就可以写成子网掩码，192.168.31.124/24  /24代表后面有24个1，c类网络，被1掩住的部分叫做网络号，被0掩住的部分叫做主机号（不能全0或者全1），将mac地址与子网掩码做与运算，得到子网号码**
  - 将A的子网掩码与B的子网掩码进行与运算，如果与完发现与自己的不在一个域中，将不会与通
- 调制解调器 把数字信号和模拟信号进行转换
-  ARP欺骗
- 默认网关：
- DHCP 
  - A类地址，B类地址，C类地址
  - DHCP广播时，先到先得
  - 局域网的ip地址是自己设置的，家用网络的IP地址是外网分配的
- 网络层：
  - 瘦腰模型：
  - **ip地址的分布是和地理位置有关的**
  - 同一根网线的两端的ip地址是不一样的，IP地址是随网卡的，不是随网线的
  - 路由表：自治的
  - tcp/ip数据包
    - TTL生存时间 **比较重要**
    - tracert baidu.com 
    - ICMP协议 tracert发送的就是icmp数据包
  - ping 发送一个ICMP协议包，ping的是ip地址
- DNS污染  
- DNS DNS服务器都是以IP地址的形式给出
- NAT协议 网络地址转换
  - SNAT / DNAT 
- UPnp
- Qos
- DDNS
- MTU
- TCP四元组 ：端口：IP  

- IP地址推导出子网掩码
  - 将IP地址和网关地址转换成二进制后补全到8位，子网掩码取IP和网关数字相同的最大位数，前面是1，后面补0。

- tracert baidu.com
  - 查看数据包经过那些地址到达目的地

- IP瘦腰模型
  - 上层是IP，下层抽象成IP，通过一个更统一的模式通信

IP数据包：校验和？


- UDP
  - 基于数据流，发出去的消息不保证送达
  - 没有状态，没有
  - ```js
           //局域网内广播，广域网无广播
           udpSock = dgram.createSocket('udp4')
           udpPort.bind(10086)//udpPort.bind+tab，查看函数udpPort.bind.toString(),查看签名
           udpSock.addMembership('239.0.0.1')//多播
           udpSock.setBroadcast(true)//发送广播
           udpSock.on('message',(msg,info)=>{console.log(info,msg.toString())})
           udpSock.send('foo',[],[],10086,'192.168.31.24')//单播//两个可选参数[]，第一个从那个位置开始发，第二个发送多少个字节
           //udpSock.address()//拿到端口的IP地址
           udpSock.send('foo',[],[],10086,'224.0.0.1')//组播
           udpSock.send('foo',[],[],10086,'225.225.225.225')//广播
           udpSock.send('foo',[],[],10086,'192.168.31.255')//广播域里的广播
    ```
- NAT
  - 端口映射
  - 外部可以主动访问内部，内部无法主动访问外部

- TCP
  - 三次握手
    - 第一次：
    - 第二次：
    - 第三次：
  - 为什么是三次？//面试题
  - 四次挥手
  - TCP四元组 
  ```js
    //tcp-ip.js 服务端
    var net = require('net')
    var server = net.createServer()
    server.on('connection', conn => {
      console.log('a connection established', conn.remoteAddress, connremotePort)
      conn.on('datal' => {
        console.log(conn.remoteAddress, data.toString())
        conn.write(data.toString().toUpperCase())
      })
      conn.on('error',() => 1)
    })
    server.listern(10010, () => {
      console.log('server listerning on port', 10010)
    })
    ////
    //客户端
    var net = require('net')
    var conn = net.connect(10010,'192.168.31.1')
    conn.on('connect', () => {
      conn.write('hello world')
      conn.on('data', data => {
        console.log(data.toString())
      })
      conn.close()
    })
  ```
  ```js
    //node
    conn = net.connect(10010,'192.168.31.124')//建立连接
    conn.write('foo')//发消息
    conn.on('data', data => console.log(data.toString()))//接收消息
  ```
- 公私钥和网络安全
  - 对称加密
  - 非对称加密
    - 原理简图：![非对称加密](公私钥与网络安全.png)
    - 证书/证书链：需要DNS服务器和证书机构的信任

- 电脑或者网页看不到了怎么办
  - ping 127.0.0.1
  - ping通自己的网关：ping不通可能是手动设置的ip地址，还是不行就该考虑局域网里是不是就没有DHCP服务器，应该打开DHCP服务器
  - ping外网：DNS设置失败
    - ping 114.114.114.114 ping不通，宽带到期了
    - 手动设置dns服务器
  - 设置中的代理服务器

##HTTP协议
###用JS发送同步请求
- ```js
    xhr = new XMLHttpRequest()
    xhr.open('http://www.baidu.com/foo/bar.html')
    //
    GET /foo/bar.html HTTP/1.1
    Host: www.baidu.com

    HTTP/1.1 403 Forbidden
    WWW-Authenticate: Basic realm="请输入账号和密码"
    //============先发送上面，在发送下面
    xhr = new XMLHttpRequest()
    xhr.open('http://user:password@www.baidu.com/foo/bar.html')
    //发送请求解析
    GET /foo/bar.html HTTP/1.1
    Host: www.baidu.com
    Authorization: Basic base64(user:password)

    HTTP/1.1 200 OK
    xxxxxx
  ```
###用js发送异步请求
- ```js
    //将异步请求的代码封装
    function get(url, callback) {
      var xhr = new XMLHttpRequest()
      xhr.open('GET', url)
      xhr.addEventListener('load', () => {
        //try {                                 //解析JSON
        //   callback(JSON.parse(xhr.responseText))
        //} catch {
          callback(xhr.responseText)
        //}
       
      })
      xhr.send()
    }
  ```
##跨域限制
- 只能请求与当前页面url在同一个域下的资源，浏览器中才会有此情况，控制台中不会
- ```js
    http://jsbin.com:8080
    http://jsbin.com
    //不在同一个域中
  ```


- 异步执行的本质，整个调用栈被清空以后，异步代码才会执行
  

- ```js
    function get(url, callback) {

    }
    function syncGet(url) {
      get(url, function(data) {

      })
      return data
    }
    var data = syncGet(url)
    //无法将异步的代码封装成同步的
  ```

#2019.08.15
##逻辑与&&
- st1 && st2 执行逻辑：
    ```js
      // statement1 && statement2 等价于：
	    {
	    if(statement1)
		    {
		    return statement2;
		    }
	    return statement1;
    	}
    ```
##逻辑或||
- st1 || st2执行逻辑：
    ```js
      // statement1 || statement2 等价于：
	   {
	    if(statement1)
		    {
		    return statement1;
	  	  }
	    return statement2;
	    }
    ```
#HTTP各种状态码及头部介绍
- 401 UnAuthorized 未授权，未登陆
- 403 Forbidden 隐藏
- 404 Not Found 未找到
  - Soft 404,返回--200的页面，称作软404，但是内容是404页面的样子，IE浏览器对小于512字节的404页面是不展示的 
- 301 Moved Permanently 永远移动到了新位置
- 302 Moved Temporarily 暂时移动到了新位置
  Location:http://www.example.com/path
  - http://www.a.com/post/101
    http://www.a.com/post/101.html (跳转到上面的链接)
- 304 Not Modified 未改变         ---==---    协商缓存
  - Cache-control 参考MDN
- 501 Not implemented
- 502 Internal Server Error 服务器内部错误

- HTTP协议：
  - 是一个文本协议，请求/响应模型，一次完整的HTTP协议过程必须是包含这两个过程的，这两个过程完成以后请求就结束了。不同于TCP可以一直收一直发，直到一端或两端把连接断掉。
- 请求相关首部：
  - User-Agent，浏览器标识，可以用js通过navigator.userAgent读到
  - Host，用来告诉服务器，浏览器是通过什么域名来连接到服务器的，带端口号。可用此特性来实现同一个服务器服务多个网站，coding/github pages就是这么做的
  - Referer，告诉服务器，浏览器是在那个页面请求的这个资源，页面完整地址，可以用来防盗链
  - If-None-Match(请求)/ETag(响应)： hash of the resource
  - If-Modified-Since(请求)/Last-Modified(响应)：ISO Time String，如果不需要更新，服务器就会响应304请求，304 Not Modified
- 响应相关首部：
  - Content-Security-Policy：告诉浏览器，页面里的js，甚至是其他资源能否被执行
  - CORS
  - Access-Control-Allow-Origin：http://www.baidu.com:8080 允许那些域下的页面里的js请求此资源
  - Access-Control-Max-Age:86400 表明此次允许跨域访问的时效是多久，过期后浏览器会重新发送OPTIONS请求以重新询问服务器是否还可以跨域访问。
  - Content-Length：配合Connection：keep-alive 可以实现Http pipe line
  - Content-Type：type/substype;charset=utf-8
  - Date:Thu, 12 Jul 2017 01:59:28 GMT
  - Expires：ISO Time String 本资源过期时间，过期之前，浏览器可以选择完全不发请求，直接使用本地缓存的版本，过后必须发请求，但可以带上If-Modify-Since，响应也可能是304  
#传统跨域方法
- iframe 套 iframe，window.top属性
- 利用window上的name属性，跨域跳转也不会发生变化的特性
- 利用服务器发送请求进行跨域
- post message
- JSONP(以前最完美) 用script标签加载js。先创建tag = document.createElement('script'),再添加src属性 tag.src = "http://xxxxx:8099/getUser?query=li&callback=foobar"然后声明函数foobar，最后append进去 document.body.appendChild(tag)

# jsonp
- ```js
    function jsonp(url, okCallback, errorCallback, timeoutCallback){

      //生成随机变量名
      var callbackName = 'JSONP_' + Math.random().toString().substr(2)

      //将随机变量名放在全局指向这个函数
      window[callbackName] =  function(data) {
        clearUp()
        if (isTimeoutInvoked) {
          return
        }
        try {
          okCallback(data)
        } catch (e) {
          console.warn(e)
        }
        delete window[callbackName]
      } 

      if (url.includes('?')) {
        url = url + '&callback=' + callbackName
      } else {
        url = url + '?callback=' + callbackName 
      }
      var tag = document.createElement('script')
      tag.src = url
      document.body.appendChild(tag)
      //面试当中需要知道创建一个全局函数指向。以及编写上面的那个函数


      //出错的情况
      tag.onerror = function(e) {
        clearUp()
        if (isTimeoutInvoked) {
          return 
        }
        errorCallback(e)
      }


      var isTimeoutInvoked = false
      var timeoutId = setTimeout(function() {
        isTimeoutInvoked = true
        timeoutCallback()
      }, 5000)     //给一个标记isTimeoutInvoked，让timeout一旦运行，ok和error不运行

      function clearUp() {
        delete window[callbackName]
        clearTimeout(timeoutId)
      }
    }
  ```
# require函数
- ```js
    function require(name) {
      if (name in require.cache) {
        return require.cache[name].exports
      }//缓存
      var code = new Function('export, module', readFile(name))
      var module = {
        export: {}
      }
      require.cache[name] = module //实现循环依赖，如果用了返回就不能实现循环依赖，如果实现循环依赖，就只能使用模块的保持对象方式

      code(module.exports, module)//在构造函数运行之前查看cache中是否已经缓存了module对象

      return module.exports

    }
    require.cache[name] = Object.create(null)//缓存
  ```
# seajs基本原本原理
- ```js
    function readFile(name, callback) {
      var xhr = new XMLHttpRequest()
      xhr.open('GET',name)
      xhr.send()
      xhr.onload = function(){
        callback(xhr.responseText)
      }
    }
    //解析出文件名
    function getDeps(source) {
      var requireMatches = source.match(/require2\s*\(\s*['"][^'"]*?['"]\s*\)/g)
      if (!requireMatches) {
        return []
      }
      var depsPath = requireMatches.map(rm => {
        return rm.match(/require2\s*\(\s*['"]([^'"]*?)['"]\s*\)/)[1]
      })
      return depsPath
    }
    //获取给定模块文件的名字，获取文件的内容
    //并分析其依赖的模块文件的名字，同时在获取它依赖的文件们
    //如何判断循环依赖是否结束，可以通过设置一个计数，启动第一个加一，启动子资源的过后减一
    //var getSourceAndDeps = function() {
    var c = 0
    function  getSourceAndDeps(name, allLoaded) {
      c++
      readFile(name,function(source) {
        require2.sourceCache[name] = source
        var deps = getDeps(source)
        deps.forEach(dep => getSourceAndDeps(dep, allLoaded))
        c--
        if (c === 0) {
          allLoaded()
        }
      })
    }
    //}()计数存在问题，污染了命名空间
    
    function require2(name) {
      var moduleFunction = new Function('module, exports', require2.sourceCache[name])
        var module = {
          exports: {}
        }
        moduleFunction(module, module.exports)
        return module.exports
    }//同步
    function use(name) {
     getSourceAndDeps(name, function() {
       require2(name)
     })
    }
    require2.sourceCache = Object.create(null)
    use(app.js) //并不是看起来异步加载并且同步返回，其实不是这样的，而是它加载完过后继续加载，直到所有文件全部加载完成过后才开始执行入口函数
  ```

# webpack
# 作业download one by one
- ```js 
    <script src = "img.js"></script>
    <script>
      imgs = imgs.slice(0, 18)
      //下载给定url的图片，下载完成后调用callback
      function downloadImg(url, callback) {
        var img = new Image()//document.create('img')
        img.onload = function() {
          callback(img)
        }
        img.onerror = function() {
          callback(img)
        }
        img.src = url
      }

      //一个一个下
      function downloadOneByOne(callback) {
        var i = 0
        run()
        function run() {
          downloadImg(imgs[i], () => {
            i++
            if (i < img.length) {
              run()
            } else {
              callback()
            }
          })
        }
      } 

      //两个一组，都下载完后下载下一组
      function downloadTwoByTwo(callback) {
        function down2Img(url1, url2, callback) {
          var count = 0
          var oneDownloaded = () => {
            count++
            if (count === 2) {
              callback()
            }
          }
          downloadImg(url1,oneDownloaded)
          downloadImg(url2,oneDownloaded)
        }
        var i = 0
        run()
        function run() {
          download2Img(imgs[i],imgs[i+1], () => {
            i+=2
            if (i < img.length) {
              run()
            } else {
              callback()
            }
          })
        }
      }
      //两个一组，一张下载完成后下载下一组
      function downloadTwoByTwo(callback) {
        function down2Img(url1, url2, callback) {
          var count = 0
          var oneDownloaded = () => {
            count++
            if (count === 1) {
              callback()
            }
          }
          downloadImg(url1,oneDownloaded)
          downloadImg(url2,oneDownloaded)
        }
        var i = 0
        run()
        function run() {
          download2Img(imgs[i],imgs[i+1], () => {
            i+=2
            if (i < img.length) {
              run()
            } else {
              callback()
            }
          })
        }

      }
      //最多同时下载四张，有任何一张下载完，就开始一张新的下载
      function downloadMax4() {
        
        var i = 0
     
        function run() {
          i++
          if (i < img.length) {
          download4Img(imgs[i] () => {
              run()
            })
          } else {
              callback()
            }
        }
        run()
        run()
        run()
        run()
        //异步代码还存在问题，
      }
      function downloadMax4() {
        async.eachLimit(imgs, 4, function(url, done) {
          downloadImg(url, () => done(null))
        },() => console.log('all is downloaded'))
      }
      //使用async进行下载，eachLimit调用function(url,done)且最多只能同时调4次，如果在调用过程中没有任何一次调用done，就不会进行下一次，如果调用done，那么立即进行下一次
    </script>
  ```
## 异步函数中的错误一般处理
- ```js
    function square(x, callback) {
      setTimeout(() => {
        callback(null, x * x)
      }, 500 + Math.random() * 1000)
    }
    //调用
    //callback在执行是有可能抛出错误，但是异步函数错误不能直接抛出，抛出到外面接不到，一般处理是将callback的第一参数设置成错误的，剩下的参数才是真的，一般设置为null
    square(3,fucntion(result) {
      console.log("the result is " , result)
    })
    //square不能直接返回结果，需要通过callback函数返回
  ```
# async.js
- ```js
    function asyncMap(ary, asyncMapper,callback) {
      var result = []
      //var count = 0
      for (let i = 0; i < ary.length; i++) {
        asyncMapper(ary[i], function(err, val) {
          //count++
          result[i] = val
          if(i === ary.length - 1) {
            callback(err, result)
          }
        })
      }
    }
    function square(val, callback) {
      callback(null, val * val)
    }
    asyncMap([1,2,3,4], square, function(err, result){
      //result is [1,4,9,16]
    })
    //
    //
    function asyncEach(ary, asyncIterator, callback) {
      for (var i = 0; i < ary.length; i++) {
        asyncIterator(ary[i], function(err){
           if(i === ary.length - 1) {
            callback(null)
          }
        })
      }
    }
    function asyncIterator(item, done){

    }
    //
    //
    function asyncFilter(ary, asyncPredicate,  callback) {
      var result = []
      //var count = 0
      for (let i = 0; i < ary.length; i++) {
        asyncPredicate(ary[i], function(err, val) {
          //count++
          if(val) {
            result[i] = ary[i]
          }
          if(i === ary.length - 1) {
            result = result.filter(it =>it)
            callback(err, result)
          }
        })
      }
    }
    //两个并行任务，同时里面有三个串行任务
    async.parallel([
      async.series.bind(async, [task1, task2, task3]),
      async.series.bind(async, [job1, job2, job3])
    ],() => console.log('all done'))
    function task1(done) {
      console.log('task1')
      setTimeout(done, 1000)
    }
    function task2(done) {
      console.log('task2')
      setTimeout(done, 2000)
    }
    function task3(done) {
      console.log('task3')
      setTimeout(done, 2000)
    }
    function job1(done) {
      console.log('job1')
      setTimeout(done, 4000)
    }
    function job2(done) {
      console.log('job2')
      setTimeout(done, 1000)
    }
    function job3(done) {
      console.log('job3')
      setTimeout(done, 3000)
    }
  ```

# jQuery 中的queue函数
- ```js
    class FunctionQueue {
      constructor () {
        this.tasks = []
        this.running = false
      }
      done() {
        if (this.tasks.length) {
          var task = this.tasks.shift()
          task(this.done.bind(this))    
        } else {
          this.running = false
        } 
      }
      queue(f) {
        if (this.running) {
          this.tasks.push(f) 
        } else {
          this.running = true
          f( this.done.bind(this))
        }
        return this
      }
    }
    //每次调用next()均不相同
    obj = new FunctionQueue();
      obj.queue(function(next) {
        console.log(1)
        next()
      }).queue(function(next) {
        setTimeout(next, 3000)
      }).queue(function(next) {
        console.log(2)
        next()
      }).queue(function(next) {
        console.log(3)
        next()
      })
    
  ```
# Promise
- ```js
    Promise.resolve = function(value) {
      return new Promise(resolve => {
        resolve(value)
        })
    }
    Promise.reject = function(value) {
      return new Promise((_, reject) => {
        reject(value)
        })
    }
    function get(value) {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(value)
        }, Math.random() * 2000)
      })
    }
    get(3).then(val => console.log(val))
    Promise.all([get(2), get(3),get(4)]).then(function(res) {
      console.log(res)
    })
    //高频面试题 Promise.all
    Promise.all = function(promises) {
      var result = []
      return new Promise((resolve, reject) => {
        for (let i = 0; i < promises.length; i++) {
          Promise.resolve(promises[i]).then(value => {
            result[i] = value
            if (i === promises.length - 1) {
              resolve(result)
            }
          }, reject)
        }
      }) 
    }//拿Promise的值只能通过then,有些可以通过valueOf拿到
    Promise.race = function(promises) {
      return new Promise((resolve, reject) => {
        promises.forEach(it => it.then(resolve, reject))
      })
    }
    Promise.race = promises =>  new Promise((resolve, reject) => promises.forEach(it => it.then(resolve, reject)))




    p = Promise.resolve(5)
    p.then(f1,f2)
    p.finally(g)   
    //等价于下面这种
    p.then(function(val) {
      setTimeout(() => g(val))
    }，reason => {
      setTimeout(() => g(reason))
    })
    //通过finally挂上去的函数总是会最后调用，不管成功还是失败都会执行，返回一个新的Promise
    p.then(f3,f4)
  ```
## 作业
- ```js
    使用promise实现getSourceAndDeps
    尝试使用promise实现图片下载的作业
    getSourceAndDeps('./app.js').then(
      function(){
        require('./app.js')
      }
    )
  ```
# Node.js中的require(X)
- 如果x看起来像一个路径（以 ./  ../  /  开头），直接加载路径对应的文件
- 如果x看起来不像一个路径：
  - 如果x是一个内置模块的名字，直接返回内置模块
  - 如果x不是一个内置模块的名字
    - 在当前文件夹的node_module文件夹里找名为x的文件夹
    - 如果此文件夹里有package.js，则加载main字段指向文件
    - 如果不存在package.json，则直接加载Y文件夹里的index文件
  - 如果在当前文件夹的node_modules里找不到名为x的文件夹
    - 向当前文件夹的父文件夹里找node_modules
    
- Node.js中的event模块的实现
  - ```js
      const EventEmitter = require('events')
      var obj = new EventEmitter()
      obj.on('foo', f1)//监听事件
      obj.off('foo',f1)//解绑事件
      obj.emit('foo',  a,b,c)//运行函数
      obj.once('foo', a,b,c)//触发一次后立即删掉
      //----------------------实现---------------------------//
      class EventEmitter {
        constructor() {
          this.eventMap = Object.create(null)
        }

        on(type, handler) {
          if (type in this.eventMap) {
            this.eventMap[type].push(handler)
          } else {
            this.eventMap[type] = [handler]
          }
          return this //实现链式调用，保证this不会断
        }

        off(type, handler) {
          if (type in this.eventMap) {
            this.eventMap[type] = this.eventMap[type].filter(it => it != handler)
          }
          return this
        }

        once(type, handler) {
          return this.on(type, function temp(...args) {
            handler.apply(this, args)
            this.off(type, temp)
          })
        }//存在问题，自己再写
        emit(type, ...args) {
          if (type in this.eventMap) {
            this.eventMap[type].forEach(handler => handler.apply(this,args))
          }
           return this 
        }
      }
    ```

- ```js
    //模块中的promise
    function readFilePromise(path) {
      return new Promise((resolve, reject) => {
        fs.readFile(path,function(err, result) {
          if (err) {
            reject(err)
          } else {
            resolve(result)
          }
        })
      })
    }
    function writeFilePromise(path, content) {
      return new Promise((resolve, reject) => {
         fs.writeFile(path, content, function(err, result) {
          if (err) {
            reject(err)
          } else {
            resolve(result)
          }
        })
      })
    }
    function promisify(f) {
      return function() {
        return new Promise((resolve, reject) => {
          f(...args, (err, reject) => {
            if(err) {
              reject(err)
            } else {
              resolve(result)
            }
          })
        })
      }
    }
    function callbackify(f) {
      return function(...args) {
        var callback = args.pop()
        f(...args).then(value => {
          callback(null, value)
        }, reason => {
          callback(reason, null)
        })
      }
    }
  ```

- http模块
- ```js
    <!-- 用http模块改写留言板 -->
    const http = require('http')
    const querystring = require('quertstring')
    const server = http.createServer()
    const port = 8080
    const msgs = []

    server.on('request', (req, res) => {
      console.log(req.method, req.url)
      
      //if (req.method === 'POST') {
      //  req.on('data', d => {
      //    d = d.toString()
      //    var query = querystring.parse(d)
      //    query.timestamp = new Date()
      //    msgs.push(query)
      //    res.writeHead(301, {
      //      loaction: '/'
      //    })
      //    res.end()
      //  })
      //  return 
      //}

      
      
    })

    server.listen(port, () => {
      console.log('server listening on port', port)
    })
  ```
- **用生成器generator优化Promise**
&&
        <!-- 高频面试题 -->
    function get(value) {
      console.log('require', value)
      return new Promise((resolve,reject) => {
        setTimeout(() => {
          console.log(value, 'end')
          resolve(value)
        }, 5000 + Math.random() * 3000)
      })
    }
      //生成器函数在done属性为真时，只有return会有值，next()不会有值
    function * g() {
      var five = yield get(5)
      try {
        var seven = yield Promise.reject(7)
        console.log(seven)  // 不会打出7，因为根本没有接到值
      } catch(e) {
        seven = e
      }
      
      var eleven = yield get(11)

      return five + seven + eleven
    } 

    function run(g) {
      return new Promise((resolve, reject) => {
        var iter = g()
        var generated
        var generated = iter.next()

        start()

        function start(value) {
          if (!generated.done) {
            generated.value.then(value => {
              generated = iter.next(value)
              start(value)
            }, reason => {
              generated = iter.throw(reason)
              start()
            })
          }
        } else {
          resolve(generated.value)
        }
      })  
    }
  ```
# 流  特点：降低内存
  - ```js
      readStream.pipe(writeStream) 

      function pipe(readStream, writeStream) {
        readStream.on('data', data => {
          writeStream.write(data)
        })

        readStream.on('data', () => {
          writeStream.end()
        })
        return writeStream
      }
    ```
  - 进程的输入输出也是流
    - process.stdin.on('data', function(d) {process.std.out.write(d.toString().toUpperCase())})
  - ```js
      const net = require('net')
      const fs = require('fs')

      const server = net.createServer(conn => {
        console.log('someone connected')
        fs.createReadStream('./dom可拖拽元素.html')
          .pipe(conn)
      })
      server.listen(10010, () => {
        console.log('10010')
      })

    ```
#跳转https
- ```js
    server.on('request', (req, res) => {

      <!-- 301跳转 -->
      res.writeHead(301, {
        location: `https://${req.headers.host}/${req.url}`
      })
      res.end()

      <!-- script标签中将location改写 -->
      res.setHeader('Content-Type', 'text/html')
      res.end(`
        <script>
          location.protocol = 'https:'
        </script>
      `)

      <!-- HSTS http严格模式 -->
    })
  ```
- handlebars/pugjs 模板引擎 lodash的template函数编译js
  - ```js
      <!-- 模板引擎最简实现 考察正则 -->
      function template(str, data) {
        return str.replace(/\{\{(.*?)\}\}/g, function(match, field) {
          return data[field]
        })
      }

      function template(str, data) {
        return str.replace(/\{\{.*?\}\}/g, function(match) {
          var field = match.match(/\{\{(.*?)\}\}/)[1]
          return data[field]
        })
      }
    ```
- node的事件循环机制 event loop

  - 
                   ┌─────────────┴─────────────┐
                   ┤        准备阶段            │
                   └───────────────────────────┘
                   ┌───────────────────────────┐
                ┌─>│           timers          │
                │  └─────────────┬─────────────┘
                │  ┌─────────────┴─────────────┐
                │  │     pending callbacks     │
                │  └─────────────┬─────────────┘
                │  ┌─────────────┴─────────────┐
                │  │       idle, prepare       │
                │  └─────────────┬─────────────┘      ┌───────────────┐
                │  ┌─────────────┴─────────────┐      │   incoming:   │
                │  │           poll            │<─────┤  connections, │
                │  └─────────────┬─────────────┘      │   data, etc.  │
                │  ┌─────────────┴─────────────┐      └───────────────┘
                │  │           check           │
                │  └─────────────┬─────────────┘
                │  ┌─────────────┴─────────────┐
                └──┤      close callbacks      │
                   └───────────────────────────┘
  - process.nextTick()函数在两个阶段之间进行调用，如果持续调用process.nextTick()，将会使函数持续卡在当前调用处
  - setImmediate()函数在check阶段运行，如果持续调用，它会走完一轮在进行重复调用
  - 在函数运行时还有一个准备阶段，在timers阶段之前，此时，setTimeout函数可能已经准备就绪，或者，process.nextTick()函数有可能执行
  - 在timers阶段前面还有一个准备阶段/初始化代码，在进入timers阶段之前就有一次执行nextTick()的机会
  - promise.then()的回调紧接着nextTick后面运行，在setImmediate()之前运行
    - ```js
        <!-- 测试代码 -->
        var fs =  require('fs')
        var p = Promise.resolve()

        fs.readFile(__filename, () => {
          process.nextTick(function f() {
            process.nextTick(f)
          })
          p.then(() => console.log(1))
        }) //如果能打出1，则在nextTick之前运行，否则在期之后运行，在poll阶段和check阶段之间转圈
      ```
  - **node11过后事件循环已经和浏览器趋于一致，在自己的测试中发现，setImmeditae总是在最后按顺序执行()执行代码为eventloop.js**
  - [事件循环简书介绍一](https://www.jianshu.com/p/deedcbf68880)
- 浏览器的事件循环机制
  - 宏任务 macro
    - 所有的事件，回调函数的事件，setTimeout,setInterval，setImmediate等等，
  - 微任务 micro
    - 主要还是Promise.resolve().then(f2)这个f2就是微任务，MutationObserver()变化监控器，监控dom变化
  - 每一次宏任务执行完过后执行微任务，也就是微任务在两次宏任务之间执行，
  - 返回结果之外的函数都是宏任务在延迟执行之后的结果，在宏任务结果之前显示，
  - 微任务又会晚于同步任务的执行
  - **先执行<script>(主程序代码是一个宏任务)中的同步任务，然后所有微任务，一个宏任务，所有微任务，一个宏任务**......
    1. 执行完主执行线程中的任务；
    2. 取出 Microtask Queue 中任务执行直到清空；
    3. 取出 Macrotask Queue 中一个任务执行；
    4. 重复 2 和 3.
  - **需要注意的是**：
    - 在浏览器页面中可以认为初始执行线程中没有代码，每一个<script>中的代码是一个独立的**task** ，即会执行完前面的<script>中创建的**microTask**再执行后面的<script>中的同步代码；
    - 如果 **microTask** 一直被添加，则会继续执行 **microTask** ，**“卡死” macroTask**；
    - 部分版本浏览器有执行顺序与上述不符的情况，可能是不符合标准或 js 与 html 部分标准冲突；
    - **Promise** 的**then**和**catch**才是 microTask ，本身的内部代码不是；
    - [事件循环简书介绍](https://www.jianshu.com/p/b221e6e36dcb)
  - ```js  
      //            js event loop (指主线程从“任务队列”中循环读取任务)
      //
      //             event queue 可能同时不止一个
      //
      //            宏任务（macrotask）event queue （macro-task(宏任务)：script(主程序代码),，setTimeout，setInterval, I/O, setImmediate      (node环境),UI rendering）
      //            ^
      //            | 异步
      //     主线程->
      //          | |  异步
      //          | V
      //          | 微任务(microtask) event queue (micro-task(微任务)：Promise，process.nextTick（node环境），Object.observe,       MutationObserver)
      //          |
      //          V
      //          如果是浏览器环境 click等事件队列总是优先于异步队列被空闲下来的JS线程取用

      // 执行顺序   script(主程序代码)—>process.nextTick—>Promises…——>setTimeout——>setInterval——>setImmediate——> I/O——>UI rendering

      // nextTick 优先级比 Promise 等 microTask 高，setTimeout和setInterval优先级比setImmediate高
    ```
#express
- 封装自http模块
- ```js
  app.use((req, res, next) {
    res.download('./app.js', 'server-code.js')
  })//下载文件，并且地址栏不发生变化，在network中查看Content-Disposition头
  ```
- ```js
  var middlewares = [
    function (req, res, next) {
      console.log(1)
      next()
    },
    function (req, res, next) {
      console.log(2)
      setTimeout(next, 2000)
    },
    function (req, res, next) {
      console.log(3)
      setTimeout(next, 3000)
    },
    function (req, res, next) {
      console.log(4)
    }]

    <!-- express原理 -->

  function compose(mws) {
    return mws.reduceRight((previous, mw) => {
      return function(...args) {
        mw(...args, function next() {
          previous(...args)
        })
      }
    }, function next(){})
  } //使用reduce倒写

  function compose(middlewares) {
    function app(req, res, next) {
      var i = 0

      runNextMW()

      function runNextMW(){
        if (i < middlewares.length) {
          middlewares[i++](req, res, runNextMW)
        }
      }
    }//基本写法
  }

  npm run start <=> npm start
  npm run test <=>  npm test
  ```
- document.cookie = xxx 设置cookie，一次只能设置一条
- 浏览器的本地存储有哪些：localstroge cookie 

#http长轮询comet
#websocket (基于tcp，通过http建立) 
- 在tcp上实现分帧后基于消息的一个功能 
- http-ws 协议升级
- upgrade请求，如websocket连接建立
##socket.io
- 基于事件，不是基于消息
- 基于websocket和comet封装
- 区别
  - 支持到ie6
  - 自己会断线重连
  - 抽象成网络两端的事件

#数据库
- 后端服务器/数据库服务器/浏览器客户端
- 日志数据库：hbase/cache数据库：redis，存储k-v对
- 表的集合
- 'U%'百分号表示0个或多个字符
- 'U_'下划线表示一个字符
- SELECT *, avg(Price) AS avgPrice FROM [Products] WHERE CategoryID > 3 GROUP BY CategoryID Having avgPrice > 30
  - 上面表示将Products表中的Price行计算平均值后选出ID>3的分组过后再选出avgPrice>30的行
- 一般是用链表存储数据，给数据库建立索引，实现快速查找
- cross join 笛卡尔积 inner join left/right join /左/右边全部留下来 outer
- create view 创建视图

#xss攻击/跨站脚本攻击，不能将用户输入的东西当代码执行,可通过将特殊符号转义，CSP解决
#csrf跨站请求伪造，在页面的其他地方放一个额外的token
#sql注入，还是不能将用户输入的东西当代码执行

#package.json文件
- scripts(命令行运行代码)/dependencies(当前包的依赖关系)/bin(自己发布一个包的时候，要提供一个命令行工具，应该怎么办)

#大型网站前端部署流程
- 强缓存和根据文件内容计算的哈希值，上线之前老版本和新版本同时存在 <script src = "jquery.js?v=asldfjl">
- 数据库
  - 事务 transaction 交易 一手交钱，一手交货 就像在付钱的时候，数据库中钱数必须一边减少一边增加
  - 数据库中表级锁 行级锁
  - 主从数据库 主数据库 增删改 从数据库执行查询 不进行写入操作
  - 缓存 redis数据库
  - 脱敏 没有办法针对性的查询某一条数据 查询日志 
  - 对于密码  加盐 md5(md5(password) + md5(salt))
  - 设计表的时候 一个实体设计一个表 范式  ORM 对象关系模型Object Realitional Model
#koa
- app.use(async (ctx, next) => {
  xxx
  next()}) //异步，通过next进行调度
- 最主要的区别时koa的next()可以感知后面的中间件

#VUE
- MVVM model->view->view->model 
- app.x=8,app.x=9，发生变化的原因是vue就地修改x属性中的setter函数，而不是创建新的
- 原始数据放在data里面，有现有数据推导出来的放在computed，事件处理放在methods
- 追踪发生的变化，在页面第一次加载的时候，就已经记录到了，
- promise的then的回调的this是window
- 数组的下标项无法被设置成setter，因为下标项太多太多了
- 给定一个对象，实现一个函数，将这个对象的所有属性及深层次属性都修改为getter/setter
  - ```js
      var obj = {
        a:1,
        b:2,
        c:{
          d:3,
          e:{
            f:5,
            g:6
          }
        }
      }

      function observer(obj) {
        function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]'
        }
        var copy = {}
        for (let key in obj) {
          if (isObject(obj[key])) {
            copy[key] = observer(obj[key])
          } else {
          copy[key] = obj[key]
          }
          
          Object.defineProperty(obj, key, {
            get: function() {
              return copy[key]
            },
            set: function(val) {
              if (isObjcet(val)) {
                val = observer(val)
              }
              copy[key] = val
            }
          })
        }
        return obj
      }

    ```
- virtual dom render函数过后会生成一个dom结构 dom diff
- data -> f(templates) -> VDom -> diff -> patch -> apply  //现代框架
- data -> patch -> apply //jquery
- v-for 中使用key 可以节约性能  li.unshift 时有key和无key可以看出明显差别
- 响应式更新 每一次对页面的修改不是实时响应更新的，是异步更新的，修改多次在未来只会触发一次
- 组件 web component
  - webcomponent定义组件(内)，new Vue实例中调用(外)
- v-model双绑原理，<input :value="searchText" @input="searchText=$event.target.value">
- 根组件的模板在根组件中求值（vue实例就是根组件，模板是#app.outHtml）
- 组件自身的模板在组件内的data作用域求值
- 谁的组件就在谁的作用域中求值
- 组件构造函数
  组件实例
    组件模板
    组件数据
    vnode
- 组件实例由组件构造函数创建，组件在构造过程中会把字符串模板编译为组件render函数，调用render函数，它会读取组件数据生成组件vnode表达的是虚拟dom， 框架计算出两次vdom的差异，更新到真实dom上去。
- this.$slots//为组件传递的子元素 render是渲染结果
- createElement()由这个对象创建出组件构造函数，然后再由组件构造函数构造出组件实例，然后再调用实例的render得到其实例的vnode
- 面试考点之一：vue的runtime版本和非runtime版本有什么区别，runtime不带模板编译
- 前端路由：不利于seo，数据需要三个来回
- html5 history模式 重要的面试题之一 服务端渲染ssr
  - URL分享给其他人的时候（直接在某个地址刷新浏览器），服务器返回正确的入口页面
  - 应用本身部署在那个地址下，让前端配置base地址，既让前端路由工具区分那部分是后端路由，那部分是前端路由
  - 相对路径，页面里的资源最好不使用相对路径，最好直接相对于网站根目录
- vuex 严格模式，禁止在commit之外去修改数据

#react 
- 是函数调用，并不是字符串模板
- 子元素(套在标签里面) 子组件(用在模板里面)
- setState 在方法中被调用是异步执行的，当在异步函数（也就是回调中）中执行的时候就是同步的
-  渲染时同一份数据用同一份key（数组）
- 通过class声明的属性是不可枚举的
- 组件的子元素只有一个的时候，this.props.children直接指向该子元素，当有2个及以上时，才是数组
- 空格会被忽略掉，如果需要空格可以在行的中间插值 {' '},也可以直接在<MyButton/> <MyButton/>打上空格
- reconciliation 协调   在做diff操作，基本策略是：元素相同时，不会删除重建，而是复用那个元素然后递归的对比子元素
- 跨层级通信，一般使用context
- 函数式组件不能有ref，因为函数式组件并不是通过构造函数构造出来的，没有实例，ref也就没有办法指向
- 一个组件要分两部分或更多的时候，使用reactPortal
- 不可变数据结构，如果深层次数据发生变化，优化应该重新渲染该处对象对应的dom，父元素顺着改变，未发生变化的节点则不渲染
- suspense 优化加载过程的loading，改善加载数据的组件的渲染方式 需要缓存
- hooks 函数组件也可已有内部状态  减少组件的嵌套层次的数量  通过调用顺序决定更新的是哪一个useState的返回结果 永远不要放在if里面，也不要调整他的运行顺序
- 高频面试题 pureComponent 和 component
- fiber 优化  将更新拆成一小片一小片的去执行 间歇式更新 在执行更新之间，浏览器依然可以响应用户，requestIdlecallback
- react 事件绑在哪里 都是由祖先元素代理 document vue 是绑在了自己身上
- import Foo, {a as b//在当前文件中叫做b, foo} from './app.js' Foo是默认导出对象 {a, foo}是非默认导出对象 const创建 import * as Foo from './foo.js' 默认导出对象直接就是Foo 所有的导出字段挂到Foo上
- import,export 与 require 的区别
  - import {a as b, f} from './a.js'
  - import与export只能出现在文件的顶层缩进层级中
  - 是语法而不是函数
  - 是静态的而不是动态的
    - 方便做语法分析与性能优化(tree shaking)
  - import创建的变量与其来源是绑定的，来源改变，变量也会发生改变
  - 上面的代码可以认为b指向a.js中的a而非a的值
#react router
- 顶层的<HashRouter></HashRouter>是一个ContextProvider, withRouter是通过context拿到内部
#redux
- redux的实现就是通过connect返回了一个可以接受上层props的组件，接收到上层数据再通过那两个函数map一下 再传给他所包装的组件
  - ```js
      function connect(mapProps, mapDispatch) {
        return function(Comp) {
          return function Component(props) {
            var store = useContext(StoreContext)
            var mappedProps = Object.assign({}, mapProps(store.getState()),mapDispatch(store.dispatch()))
            return <Coomp {...ptops} {...mappedProps}></Comp>
          }
        }
      }
    ```
- immer 结构共享的不可变数据结构 使用的是es6的proxy代理来做的




# es6
- proxy 可以拦截对对象的各种形式的访问
##错题一：LeetCode20题
##原因：对于map的理解不清晰
- ```js
  var map = {
      "(": ")",
      "[": "]",
      "{": "}"
  } 

  var isValid = function(s) {
      var stack = [];
      for (var i = 0; i < s.length; i++) {
          var el = s[i];
          if (map[el]) {
              stack.push(map[el]);
          } else {
              if (el !== stack.pop()) {
                  return false;
              }
          }
      }
      return stack.length === 0;
  };
  //map[el] 取出的是 ( ， 但实际上存入的值是 )
  ```
##错题二：LeetCode第665题
##原因：暂不明，根本无心学习，看别人答案都看不懂，以后重写一遍
- ```js
  var checkPossibility = function(nums) {
  let count = 0
  for (let i = 0; i < nums.length; i++) {
    if ( nums[i] < nums[i-1]) {
      count++
      if (count >= 2) {
        return false  //计数两次肯定错误
      }
      if (nums[i] <= nums[i-2] && nums[i+1] <= nums[i-1]) {
        return false
      }  //如果两个需要换的数，小于其前面两项，那么肯定是错的
    } 
  }
  return true  
  };
  ```
##错题三：LeetCode第414题，求第三大数
##原因：题写的不够，脑子不开光啊
- ```js
  var thirdMax = function(nums) {
    let max = nums[0]
    let min = nums[0]
    for (let i = 0; i < nums.length; i++) {
      max = Math.max(max, nums[i])
      min = Math.min(min ,nums[i])
    }
    let second = min 
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] < max)
      second = Math.max(second, nums[i])
    }
    if (nums.length < 3) {
      return max
    }
    let third = min
   for (let i = 0; i < nums.length; i++) {
      if (nums[i] < second){
        third = Math.max(third, nums[i])
      }
    }
    return second === third ? max : third
  };
  //具体思路为，先求最大最小值，再将最小值与最大值之间的最大值b，再求b与最小值之间的最大值c，输出c
  ```
##错题四：LeetCode第977题
##错题原因：循环条件没想明白，还是对提的理解不够
- ```js
    var sortedSquares = function(A) {
      let res = [];
      let up = 0, down = A.length-1;
      while(up <= down) {
        let a =   A[up] * A[up];
        let b = A[down] * A[down];
        if(a > b) {
          res.push(a);
          up++;
        } else {
          res.push(b);
          down--;
        }
      }
      return res.reverse();
    };
    //思路：因为已经排序了，主要需要判断左右值的比较，可以从两头取数，此时while循环就很好用了，左右各取数，如果左比右大，push左，否则，push右，当左右相遇时结束，再将数组翻转即可
  ```
##同理题：LeetCode905
- ```js
  var sortArrayByParity = function(A) {
    var temp,swap, i =0, j = A.length;
    while (i <= j){
      swap = false; 
      if(A[i] % 2 != 0){
        swap = true;
      }else{
        i = i+1;
      }
      if(A[j] % 2 === 0){            
        if(swap === true){
          temp = A[i];
          A[i]= A[j];
          A[j] = temp;
            i = i+1;
            j = j-1;
        }
      } else	{
        j = j-1;
      }     
    }           
    return A;
  };
  //从后面找偶数换掉前面的奇数，当i，j相遇时，数组就走完了，再返回数组
  ```
##2019-02-17 正则习题
###Credit Card Mask
- ```js
      function maskify(cc) {
        return cc.replace(/^(.*)(....)$/,(match, $1, $2) => {
          return '#'.repeat($1.length) + $2
        })
        //return cc.replace(/.(?=.{4,})/g. '#')每一个字符它的右边至少都有4个字符
      }
  ```
##打印出1到10 阿里面试题 生成器
- ```js
    Number.prototype[Symbol.iterator] = function * (){
      for (var i = 1; i <= this; i++) {
        yield i
      }
    }
    for (let val of 10) {
      console.log(val)
    }
    //====
    Number.prototype[Symbol.iterator] = function () {
      var self = this
      var i = 1
      return {
        next: function() {
          if (i <= self) {
            return {
              value: i++,
              done:false
            }
          } else {
            return {
              value: undefined,
              done: true
            }
          }
        }
      }
    }
  ```
- ```javascript
    //作业：补全代码使其能够返回1 2 5 9 3
     var n = 12593
    //TODO
    Number.prototype.digits = function*(){
      var n = this.valueOf()
      var digit = n % 10
      var n = (n - digit) / 10

      if (n >= 1) {
        yield * n.digits()
      }
      yield digit
    }
    //TODO
    for(var digit of n.digits()){
      console.log(digit)
    }
    //===
    var n = 12593
    Number.prototype.digits = function *(){
      var n = this.valueOf()
      var digit
      while(n >= 1) {
        var digit = n % 10
        var n = (n - digit) / 10
        yield digit 
      }
    }
    for(var digit of n.digits()){
      console.log(digit)
    }
  ```
##leetcode 53题 MaxSubArray
- ```js
    /**
      * @param {number[]} nums
      * @return {number}
    */
    var maxSubArray = function(nums) {
      var max_ending = 0
      var max_index = nums[0]
      for (let x of nums) {
        max_ending = Math.max(x , max_ending + x)
        max_index = Math.max(max_index , max_ending)
      }
      return max_index
      };
      //动态规划 Kadane算法，题目大意，给定一数组，返回数组中子数组中的最大和
  ```
1.27课程重新看